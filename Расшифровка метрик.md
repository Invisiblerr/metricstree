#Метрики класса:

  -Condition Nesting Depth(Глубина вложенности условия) - Эта метрика измеряет максимальную глубину вложенности операторов условий. Когда операторы слишком глубоко вложены в код, их становится трудно понять. Это связано с тем, что для понимания глубоко вложенной строки требуется понимание контекста этой строки. Метод с высоким уровнем вложенности может быть очень сложным для понимания. Как подмечено в S. McConnell, Code Complete, 2nd Edition, В§19.4. Microsoft Press, 2004.
  человеческий мозг не может легко обрабатывать более трех уровней вложенных операторов if.
  __________________________________________________________________________________________________________________________________________________________________
  
  -Lines Of Code - Строки кода просто подсчитывают строки исходного кода (символы разрыва строк) определенного метода. Это простая, но мощная метрика для оценки сложности методов. Поскольку метрика зависит от соглашений и формата кода, очень важно использовать ее в сгенерированном коде, поскольку в нем могут отсутствовать разрывы строк. Кроме того, ее можно измерить только в самом исходном коде с front-end, и поэтому она является метрикой front-end.
  
  Согласно FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55. Обычное значение метрики меньше 11, случайное между 11 и 30, редкое свыше 30
  
  Сильно связанные качественные свойства
  ________________________________________

    Re-Usability

как отрицательно, так и положительно зависит от размера.

-Understandability for Reuse

Понимание того, подходит ли класс для повторного использования, зависит от его размера. Понятность снижается с увеличением LOC
Понятность снижается с увеличением LOC.
________________________________________

-Attractiveness

Привлекательность метода зависит от размера потенциально повторно используемого кода.
Привлекательность увеличивается с увеличением LOC.
________________________________________

    Maintainability

уменьшается с увеличением LOC.

-Analyzability

Затрачиваемые усилия и время на диагностику недостатков или причин сбоев в методе или на идентификацию частей, подлежащих модификации, напрямую связаны с его размером.

Анализируемость снижается с увеличением LOC.
________________________________________

-Changeability

Изменение метода требует предварительного понимания, что, в свою очередь, более сложно для больших систем.
Изменчивость снижается с увеличением LOC.
________________________________________

-Testability

Полное тестирование требует охвата всех путей выполнения. Количество возможных путей выполнения метода увеличивается с его размером.
Тестируемость снижается с увеличением LOC.
________________________________________

    Portability

declines with increasing LOC.

-Adaptability

Что касается изменчивости, размер метода имеет прямое влияние. Каждая модификация требует понимания, что сложнее для больших систем.
Адаптивность снижается с увеличением LOC.
________________________________________


    Связанные качественные свойства

    Functionality
может увеличиться с увеличением LOC.

-Interoperability

Совместимость требует возможности локализовать части системы, отвечающие за совместимость. Размер этих частей может указывать на лучшую способность к взаимодействию.
Совместимость может увеличиться с увеличением LOC.
________________________________________

-Security

Чтобы связать LOC с безопасностью, необходимо иметь возможность определить местонахождение частей системы, отвечающих за безопасность. Размер этих частей может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением LOC.
________________________________________

    Reliability
    
может увеличиться с увеличением LOC

-Maturity

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут остаться ошибки. Следовательно, на зрелость также может отрицательно влиять размер кода.
Зрелость может снизиться с увеличением LOC.
________________________________________

-Fault-tolerance

Чтобы связать LOC с отказоустойчивостью, необходимо иметь возможность локализовать части системы, отвечающие за отказоустойчивость. Размер этих частей может указывать на лучшую способность к взаимодействию.
Отказоустойчивость может увеличиваться с увеличением LOC.
________________________________________

-Recoverability

Чтобы связать LOC с восстанавливаемостью, необходимо иметь возможность найти части системы, ответственные за восстанавливаемость. Размер этих частей может указывать на более высокую степень восстановления.
Восстанавливаемость может увеличиться с увеличением LOC.
________________________________________

    Re-Usability
    
может уменьшаться с увеличением LOC.

-Learnability for Reuse

Изучение того, подходит ли метод для повторного использования, зависит от размера и сложности его интерфейса. LOC — это общая метрика размера, но не конкретная оценка размера и сложности интерфейса.
Обучаемость может снижаться с увеличением LOC.
________________________________________

-Operability for Reuse - Programmability

Насколько хорошо класс может быть интегрирован, зависит от сложности его интерфейса. LOC — это общая метрика размера, но не конкретная оценка размера и сложности интерфейса.
Программируемость может снижаться с увеличением LOC.
________________________________________

    Efficiency
может снижаться с увеличением LOC.

-Time Behavior

Статический размер может указывать на более высокое время выполнения из-за увеличения количества промахов кэша инструкций, длинных переходов и т. д.
Поведение во времени может ухудшиться с увеличением LOC.
________________________________________

-Resource Utilization

Статический размер может указывать на более высокое использование памяти.
Использование ресурсов может ухудшиться с увеличением LOC.
________________________________________

    Maintainability
    
уменьшается с увеличением LOC.

-Stability

Из-за ограниченной анализируемости и тестируемости размер также может отрицательно влиять на стабильность.
Стабильность может снижаться с увеличением LOC.
________________________________________

    Portability
уменьшается с увеличением LOC.

-Replaceablity

Заменитель компонента должен имитировать его наблюдаемое поведение. Большие компоненты могут иметь более сложное наблюдаемое поведение, что затрудняет проверку взаимозаменяемости и фактическую замену компонента. Размер и сложность интерфейса, атрибут, напрямую связанный с заменяемостью, специально не оцениваются LOC.
Заменяемость может снижаться с увеличением LOC.
________________________________________
  
  __________________________________________________________________________________________________________________________________________________________________
  -Loop Nesting Depth(Глубина вложенности циклов) - Эта метрика измеряет максимальную глубину вложенности операторов цикла. Когда операторы слишком глубоко вложены в код, их становится трудно понять. Это связано с тем, что для понимания глубоко вложенной строки требуется понимание контекста этой строки. Метод с высоким уровнем вложенности может быть очень сложным для понимания. Кроме того, значение этой метрики может быть полезно для оценки временной сложности данного метода.
  
   __________________________________________________________________________________________________________________________________________________________________
    McCabe Cyclomatic Complexity (CC)
McCabe Cyclomatic Complexity (CC) это мера управления структурой сложности программного обеспечения. это количество линейно независимых путей и, следовательно минимальное количество путей выполнения ПО. 

Согласно с

FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.
обычное значение этой метрики меньше 3, случайное — между 3 и 4, редкое — больше 4.

________________________________________
    Сильно связанные качественные свойства
    
    Re-Usability
как отрицательно, так и положительно влияет атрибутивная оценка с цикломатической сложностью.

-Understandability for Reuse

Понимание того, подходит ли класс для повторного использования, зависит от его сложности.
Понятность снижается с увеличением цикломатической сложности.
________________________________________

-Learnability for Reuse

Изучение того, подходит ли класс для повторного использования, зависит от сложности его интерфейса. Системы с высокой сложностью управления также могут иметь сложный (поведенческий) интерфейс.
Обучаемость снижается с увеличением цикломатической сложности.
________________________________________

-Operability for Reuse - Programmability

Насколько хорошо класс может быть интегрирован, зависит от сложности его интерфейса. Системы с высокой сложностью управления также могут иметь сложный (поведенческий) интерфейс.
Программируемость снижается с увеличением цикломатической сложности.
________________________________________

-Attractiveness

Привлекательность класса зависит от сложности потенциально повторно используемого кода. Цикломатическая сложность позволяет оценить сложность.
Привлекательность увеличивается с увеличением цикломатической сложности.
________________________________________

    Maintainability
снижается с увеличением цикломатической сложности.

-Analyzability

Затрачиваемые усилия и время на диагностику недостатков или причин отказов или на идентификацию частей, подлежащих модификации, напрямую связаны с количеством путей выполнения, т. е. сложностью потока управления.
Анализируемость снижается с увеличением цикломатической сложности.
________________________________________

-Changeability

Каждая модификация должна быть правильной для всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Изменчивость снижается с увеличением цикломатической сложности.
________________________________________

-Testability

Полное тестирование требует охвата всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Тестируемость снижается с увеличением цикломатической сложности.
________________________________________

    Portability
снижается с увеличением цикломатической сложности.

-Adaptability

Что касается изменчивости, то непосредственное влияние оказывает сложность управляющей структуры программного обеспечения. Каждая модификация должна быть правильной для всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Адаптивность снижается с увеличением цикломатической сложности.
________________________________________

-Replaceablity

Заменитель компонента должен имитировать его наблюдаемое поведение. Компоненты со сложными управляющими структурами могут иметь более сложное наблюдаемое поведение, что затрудняет проверку взаимозаменяемости и фактическую замену компонента.
Заменяемость снижается с увеличением цикломатической сложности.
________________________________________

    Связанные качественные свойства
________________________________________    
    
    Functionality
    
может увеличиваться с увеличением цикломатической сложности.

-Interoperability

Связь цикломатической сложности с совместимостью требует наличия частей системы, ответственных за совместимость. Сложность в этих частях может указывать на лучшую способность к взаимодействию.
________________________________________

-Security

Чтобы связать цикломатическую сложность с безопасностью, необходимо уметь находить части системы, отвечающие за безопасность. Сложность в этих частях может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением цикломатической сложности.
________________________________________

    Reliability
    
может увеличиваться с увеличением цикломатической сложности.


-Maturity

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут оставаться ошибки. Следовательно, на зрелость также может негативно повлиять сложность потока управления.
Зрелость может снижаться с увеличением цикломатической сложности.
________________________________________

-Fault-tolerance

Для связи цикломатической сложности с отказоустойчивостью необходимо иметь возможность локализовать части системы, отвечающие за отказоустойчивость. Сложность в этих частях может указывать на лучшую способность к взаимодействию.
________________________________________

-Recoverability

Связь цикломатической сложности с восстанавливаемостью требует возможности локализовать части системы, ответственные за восстанавливаемость. Сложность в этих частях может указывать на более высокую возможность восстановления. Возможность восстановления может увеличиться с увеличением CC
________________________________________

    Efficiency
    
может снижаться с увеличением цикломатической сложности.

-Time Behavior

Статическая сложность может указывать на более высокую сложность выполнения.
Поведение времени может ухудшиться с увеличением цикломатической сложности.
________________________________________

    Maintainability
снижается с увеличением цикломатической сложности.
________________________________________

-Stability

Из-за ограниченной анализируемости и тестируемости на стабильность также может отрицательно повлиять сложность потока управления.
Стабильность может снижаться с увеличением цикломатической сложности.
________________________________________
________________________________________________________________________________________________________________________________________________________________
Number Of Loops

Этот показатель измеряет количество циклов в данном методе.
________________________________________________________________________________________________________________________________________________________________

Number Of Parameters To Method

Эта метрика измеряет количество параметров метода или конструктора. Метод (или конструктор), который использует большое количество формальных параметров, усложняет обслуживание:
Написать вызов метода сложно, потому что программист должен знать, как указать соответствующее значение для каждого параметра.
Внешне сложно понять, потому что вызовы метода длиннее одной строчки кода.
Внутренне сложно понять, потому что у него так много зависимостей.

Robert C. Martin, in [1], пишет (page 40):

Идеальное количество аргументов для функции равно нулю (ниладический). Далее идет один (монадический), за ним два (диадический). По возможности следует избегать трех аргументов (троичных). Более трех (полиадический) требует особого обоснования, и тогда его не следует использовать в любом случае.
Ограничьте количество формальных параметров для метода в зависимости от причины большого числа:
Некоторые параметры логически связаны, но передаются в метод по отдельности. Параметры, которые логически связаны, должны быть сгруппированы вместе (see the 'Introduce Parameter Object' refactoring on pp. 238-242 of [2]).

У метода слишком много обязанностей. Он должен быть разбит на несколько методов (see the 'Extract Method' refactoring on pp. 89-95 of [2]), и каждому новому методу должно быть передано подмножество исходных параметров.

Метод имеет избыточные параметры, которые не используются. Две основные причины этого: (1) параметры были добавлены для расширения в будущем, но никогда не используются;(2) тело метода было изменено таким образом, что он больше не использует определенные параметры, но сигнатура метода не была соответствующим образом обновлена. В обоих случаях теоретически правильным решением является удаление неиспользуемых параметров. (see the 'Remove Parameter' refactoring on pp. 223-225 of [2]), хотя вы должны делать это осторожно, если метод является частью опубликованного интерфейса.

Когда метод является частью опубликованного интерфейса, одним из возможных решений является добавление в интерфейс нового метода-оболочки с более аккуратной подписью. Кроме того, вы можете опубликовать новую версию интерфейса с улучшенным дизайном.Однако ясно, что ни одно из этих решений не является идеальным, поэтому вам следует с самого начала позаботиться о правильном проектировании интерфейсов. Особенно плоха практика добавления параметров для будущей расширяемости. Это сбивает с толку других программистов, которые не уверены, какие значения им следует передавать для этих ненужных параметров, и добавляет неиспользуемый код, который потенциально трудно удалить позже.

1. Robert C. Martin. Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall, 2008.
2. Martin Fowler. Refactoring. Addison-Wesley, 1999.
 ________________________________________________________________________________________________________________________________________________________________

    Data Abstraction Coupling (DAC)


Data Abstraction Coupling DAC(C) определяется как количество атрибутов в классе C, которые имеют другой класс в качестве своего типа. DAC измеряет сложность связи, вызванную абстрактными типами данных (ADT). Этот показатель связан со связью между классами, представляющими основной аспект ООП, поскольку степень повторного использования, усилия по обслуживанию и тестированию класса в решающей степени зависят от уровня связи между классами.
Входит в набор показателей, предложенный Ли и Генри, см.

W. Li and S. Henry. Object-oriented metrics that predict maintainability. Journal of Systems and Software, Volume 23, Issue 2, pages 111-122, November 1993.

  Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
отрицательно влияет сцепление.

-Understandability for Reuse:

Часть системы, имеющая высокую (исходящую) эфферентную связь, может быть в значительной степени обратно связана с понятностью, поскольку она использует другие части системы, которые также необходимо понять.
Понятность снижается с увеличением DAC.
________________________________________

-Attractiveness:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с привлекательностью, поскольку они используют другие части системы, которые также необходимо понимать, и представляют собой зависимости.
Привлекательность снижается с увеличением DAC.
________________________________________

  Maintainability

уменьшается с увеличением DAC.


-Analyzability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно пропорциональны анализируемости, поскольку они используют другие части системы, которые также необходимо анализировать.
Анализируемость снижается с увеличением DAC.
________________________________________

-Changeability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны изменчивости, поскольку они используют другие части системы, которые также могут нуждаться в изменении.
Изменчивость уменьшается с увеличением DAC.
________________________________________

-Stability:

Части, демонстрирующие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны стабильности, поскольку они используют другие части системы, которые могут влиять на них.
Стабильность снижается с увеличением DAC.
________________________________________

-Testability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с тестируемостью, поскольку они используют другие части системы, которые увеличивают количество возможных путей тестирования.
Тестируемость снижается с увеличением DAC.
________________________________________

  Portability
  
уменьшается с увеличением DAC.


-Adaptability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны адаптивности, поскольку они используют другие части системы, которые также могут нуждаться в адаптации.
Адаптивность снижается с увеличением DAC.
________________________________________

  Связанные качественные свойства
  ________________________________________
  
  Functionality
  
взаимосвязь оказывает как отрицательное, так и положительное влияние.


-Interoperability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть непосредственно связаны с интероперабельностью, поскольку они используют/взаимодействуют с другими частями системы.
Совместимость может увеличиться с увеличением DAC.
________________________________________

-Security:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны безопасности, поскольку на них могут влиять проблемы безопасности в других частях системы.
Безопасность может снизиться с увеличением DAC.
________________________________________

  Reliability
может уменьшаться с увеличением DAC.

-Fault-tolerance:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны отказоустойчивости, поскольку на них могут влиять сбои в других частях системы.
Отказоустойчивость может снизиться с увеличением DAC.
________________________________________

-Recoverability:

Части, имеющие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны восстанавливаемости, поскольку их данные распределяются по другим частям системы, что затрудняет их восстановление.
Восстанавливаемость может уменьшиться с увеличением DAC.
________________________________________

  Re-Usability
  
может уменьшаться с увеличением DAC.

-Learnability for Reuse:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, которые также необходимо понимать.
Обучаемость может снизиться с увеличением DAC.
________________________________________

-Operability for Reuse - Programmability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, представляющие зависимости.
Программируемость может уменьшиться с увеличением DAC.
________________________________________

  Efficiency
  
может уменьшаться с увеличением DAC.

-Time Behavior:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны поведению во времени, поскольку они используют другие части системы, поэтому выполнение во время теста или операции не остается локальным, а может включать в себя огромные части системы.
Поведение во времени может ухудшиться с увеличением DAC.
________________________________________

Resource Utilization:
Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны утилизации ресурсов, поскольку они используют другие части системы, поэтому выполнение во время тестирования или работы не остается локальным, а может включать в себя огромные части системы.
Использование ресурсов может ухудшиться с увеличением DAC.
________________________________________
________________________________________________________________________________________________________________________________________________________________


    Depth of Inheritance Tree (DIT)
    
Глубина дерева наследования (DIT) — это максимальная длина пути от класса к корневому классу в структуре наследования системы. DIT измеряет, сколько суперклассов может повлиять на класс.
Входит в набор показателей, предложенный Чидамбером и Кемерером, см.

S. R. Chidamber and C. F. Kemerer. A Metrics Suite for Object Oriented Design. In IEEE Transactions on Software Engineering, volume 20 (6), pages 476-493, June 1994.
According to
FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.

обычное значение этой метрики меньше 3, случайное — между 3 и 4, редкое — больше 4


   Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
как отрицательно, так и положительно влияет атрибутивная оценка с помощью DIT.

-Understandability for Reuse:

Понимание того, подходит ли класс для повторного использования, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Понятность снижается с увеличением DIT.
________________________________________

-Learnability for Reuse:

Изучение того, как использовать класс, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Обучаемость снижается с увеличением DIT.
________________________________________

-Operability for Reuse - Programmability:

Насколько хорошо класс может быть интегрирован, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Программируемость снижается с увеличением DIT.
________________________________________

-Attractiveness:

Привлекательность класса зависит от размера потенциально повторно используемого javaCode. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов.
Привлекательность увеличивается с увеличением DIT.
________________________________________

  Maintainability
  
уменьшается с увеличением ДИТ.

-Analyzability:

Затрачиваемые усилия и время на диагностику недостатков или причин отказов в классе или на идентификацию частей, подлежащих модификации, связаны с количеством методов класса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Анализируемость снижается с увеличением DIT.
________________________________________

-Changeability:

Изменение класса требует предварительного понимания, что, в свою очередь, более сложно для классов со многими методами. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Более того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его понимание.
Изменчивость снижается с увеличением DIT.
________________________________________

-Testability:

Полное тестирование требует охвата всех путей выполнения. Количество возможных путей выполнения класса увеличивается с количеством методов и сложностью их потока управления. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Из-за позднего связывания методы суперкласса необходимо снова тестировать в контексте подкласса. Это потенциально усложняет тестирование классов глубоко в иерархии классов.
Тестируемость снижается с увеличением DIT.
________________________________________

  Portability
  
уменьшается с увеличением ДИТ.

-Adaptability:

Что касается изменчивости, размер программного обеспечения имеет прямое влияние. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Адаптивность снижается с увеличением DIT.
________________________________________

-Replaceablity:

Заменитель компонента должен имитировать его интерфейс. Большие интерфейсы трудно проверить на взаимозаменяемость и реально заменить. Размер интерфейса увеличивается для классов, которые находятся глубоко в иерархии классов.
Заменяемость снижается с увеличением DIT.
________________________________________

  Связанные качественные свойства
  ________________________________________
  Functionality
  
может увеличиться с увеличением DIT.

-Interoperability:

Чтобы связать DIT с совместимостью, необходимо иметь возможность локализовать иерархические (под)структуры системы, ответственные за совместимость. Высокий DIT в этих иерархических (под)структурах может указывать на лучшую способность к взаимодействию.
Совместимость может увеличиться с увеличением DIT.
________________________________________

-Security:

Связь DIT с безопасностью требует наличия иерархических (под)структур системы, ответственных за совместимость. Высокое значение DIT в этих иерархических (под)структурах может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением DIT.
________________________________________

  Reliability
  
как положительно, так и отрицательно влияют атрибуты, оцениваемые с помощью DIT.

-Maturity:

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут оставаться ошибки. Следовательно, DIT также может негативно повлиять на зрелость.
Зрелость может снизиться с увеличением DIT.
________________________________________

-Fault-tolerance

Связь DIT с отказоустойчивостью требует наличия возможности локализовать иерархические (под)структуры системы, отвечающие за взаимодействие. Высокий DIT в этих иерархических (под)структурах может указывать на лучшую способность к взаимодействию.
Отказоустойчивость может увеличиться с увеличением DIT.
________________________________________

-Recoverability

Чтобы связать DIT с возможностью восстановления, необходимо иметь возможность локализовать иерархические (под)структуры системы, отвечающие за совместимость. Высокое значение DIT в этих иерархических (под)структурах может указывать на более высокую восстанавливаемость.
Восстанавливаемость может увеличиться с увеличением DIT.
________________________________________

  Efficiency
  
может снижаться с увеличением DIT.

-Time Behavior:

Статический размер может указывать на более высокое время выполнения из-за увеличения числа промахов кэша инструкций, длинных переходов и т. д. Классы, наследующие множество атрибутов, потенциально велики. Кроме того, позднее связывание требует непрямых вызовов и предотвращает оптимизацию в контексте вызывающего объекта.
Поведение во времени может ухудшиться с увеличением DIT.
________________________________________

-Resource Utilization:

Статический размер может указывать на более высокое использование памяти.
Использование ресурсов может ухудшиться с увеличением DIT.
________________________________________

  Maintainability
  
уменьшается с увеличением ДИТ.

-Stability:

Из-за ограниченной анализируемости и тестируемости размер также может отрицательно влиять на стабильность.
Стабильность может снижаться с увеличением DIT.
________________________________________
________________________________________________________________________________________________________________________________________________________________

    Lack of Cohesion of Methods (LCOM)

Метрика «Отсутствие связности в методах» — это мера количества несвязанных пар методов в классе, представляющем независимые части, не имеющие связности. Он представляет собой разницу между количеством пар методов, не имеющих общих переменных экземпляра, и количеством пар методов, имеющих общие переменные экземпляра.
Входит в набор показателей, предложенных Chidamber and Kemerer, см.

S. R. Chidamber and C. F. Kemerer. A Metrics Suite for Object Oriented Design. In IEEE Transactions on Software Engineering, volume 20 (6), pages 476-493, June 1994.

  Сильно связанные качественные свойства
________________________________________

  Reliability
  
положительно влияет на связанность.

-Maturity

Части системы, демонстрирующие высокую связанность, могут быть напрямую связаны со зрелостью, поскольку зрелая система должна иметь высокие значения связи
________________________________________

-Re-Usability

отрицательно влияет сцепление.

-Understandability for Reuse

Части системы, демонстрирующие высокую связность, могут быть напрямую связаны с понятностью для повторного использования, поскольку они реализуют только одну концепцию.
Понятность снижается с увеличением LCOM.
________________________________________

-Attractiveness

Части системы, демонстрирующие высокую связность, могут иметь непосредственное отношение к привлекательности для повторного использования, поскольку они реализуют только одну концепцию.
Привлекательность снижается с увеличением LCOM.
________________________________________

  Maintainability
уменьшается с увеличением LCOM.

-Analyzability

Части системы, демонстрирующие высокую связность, могут иметь непосредственное отношение к анализируемости, поскольку они реализуют только одну концепцию.
Анализируемость снижается с увеличением LCOM.
________________________________________

-Changeability

Части системы, демонстрирующие высокую сплоченность, могут иметь непосредственное отношение к изменчивости, поскольку они реализуют только одну концепцию.
Изменчивость уменьшается с увеличением LCOM.
________________________________________

Stability
Части системы, демонстрирующие высокую связанность, могут иметь непосредственное отношение к стабильности, поскольку они реализуют только одну концепцию.
Стабильность снижается с увеличением LCOM.
________________________________________

Testability
Части системы, демонстрирующие высокую связность, могут иметь непосредственное отношение к тестируемости, поскольку они реализуют только одну концепцию.
Тестируемость снижается с увеличением LCOM.
________________________________________

  Portability
  
уменьшается с увеличением LCOM.

-Adaptability

Части системы, демонстрирующие высокую связность, могут иметь прямое отношение к адаптивности, поскольку они реализуют только одну концепцию.
Адаптивность снижается с увеличением LCOM.


  связанные качественные свойства
  ________________________________________
  
  
  Re-Usability
  
может уменьшаться с увеличением LCOM.

-Learnability for Reuse

Части системы, демонстрирующие высокую связность, могут иметь непосредственное отношение к обучаемости, поскольку они реализуют только одну концепцию.
Обучаемость может снижаться с увеличением LCOM.
________________________________________

-Operability for Reuse - Programmability

Части системы, демонстрирующие высокую связность, могут быть напрямую связаны с программируемостью, поскольку они реализуют только одну концепцию.
Программируемость может уменьшиться с увеличением LCOM.
________________________________________

Efficiency

может уменьшаться с увеличением LCOM.


-Time Behavior

Части системы, демонстрирующие высокую связность, могут быть напрямую связаны с поведением во времени, поскольку они реализуют только одну концепцию и не выполняют никаких не связанных между собой трудоемких задач.
Поведение времени может ухудшиться с увеличением LCOM.
________________________________________

-Resource Utilization

Части системы, демонстрирующие высокую связность, могут быть непосредственно связаны с использованием ресурсов, поскольку они реализуют только одну концепцию и не используют никакое постороннее использование ресурсов.
Использование ресурсов может ухудшиться с увеличением LCOM.
________________________________________

  Portability
  
уменьшается с увеличением LCOM.

-Replaceablity

Части системы, демонстрирующие высокую связность, могут иметь прямое отношение к заменяемости, поскольку реализуют только одну концепцию.
Заменяемость может уменьшаться с увеличением LCOM.
________________________________________
________________________________________________________________________________________________________________________________________________________________

    Message Passing Coupling (MPC)
    
    
Связь передачи сообщений MPC(C) определяется как количество операторов отправки, определенных в классе C. MPC измеряет количество вызовов методов, определенных в методах класса, для методов других классов и, следовательно, зависимость локальных методов от методов, реализованных другими классами. Это позволяет делать выводы о передаче сообщений (вызовах методов) между объектами задействованных классов. Это позволяет сделать выводы о возможности повторного использования, обслуживании и тестировании.

Входит в набор показателей, предложенный Ли и Генри, см.

W. Li and S. Henry. Object-oriented metrics that predict maintainability. Journal of Systems and Software, Volume 23, Issue 2, pages 111-122, November 1993.

  Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
отрицательно влияет на связывание.

-Understandability for Reuse:

Часть системы, которая имеет высокую (исходящую) эфферентную связь, может быть в значительной степени обратно связана с понятностью, поскольку она использует другие части системы, которые также необходимо понять.
Понятность снижается с увеличением MPC.
________________________________________

-Attractiveness:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с привлекательностью, поскольку они используют другие части системы, которые также необходимо понимать, и представляют собой зависимости.
Attractiveness decreases with increasing MPC.
________________________________________

  Maintainability
  
Привлекательность снижается с увеличением MPC.

Analyzability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно пропорциональны анализируемости, поскольку они используют другие части системы, которые также необходимо анализировать.
Анализируемость снижается с увеличением MPC.
________________________________________

-Changeability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны изменчивости, поскольку они используют другие части системы, которые также могут нуждаться в изменении.
Изменяемость уменьшается с увеличением MPC.
________________________________________

-Stability:

Части, демонстрирующие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны стабильности, поскольку они используют другие части системы, которые могут влиять на них.
Стабильность снижается с увеличением MPC.
________________________________________

-Testability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с тестируемостью, поскольку они используют другие части системы, которые увеличивают количество возможных путей тестирования.
Тестируемость снижается с увеличением MPC.
________________________________________

  Portability
  
уменьшается с увеличением MPC.

Adaptability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны адаптивности, поскольку они используют другие части системы, которые также могут нуждаться в адаптации.
Адаптивность снижается с увеличением MPC.
________________________________________

   Связанные качественные свойства
   ________________________________________
   
  Functionality

взаимосвязь оказывает как отрицательное, так и положительное влияние.

-Interoperability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть непосредственно связаны с совместимостью, поскольку они используют/взаимодействуют с другими частями системы.
Совместимость может увеличиться с увеличением MPC.
________________________________________

-Security:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны безопасности, поскольку на них могут влиять проблемы безопасности в других частях системы.
Безопасность может снизиться с увеличением MPC.
________________________________________

  Reliability
  
может уменьшаться с увеличением MPC.

Fault-tolerance:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны отказоустойчивости, поскольку на них могут влиять сбои в других частях системы.
Отказоустойчивость может снизиться с увеличением MPC.
________________________________________

-Recoverability:

Части, имеющие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны восстанавливаемости, поскольку их данные распределяются по другим частям системы, что затрудняет их восстановление.
Восстанавливаемость может снижаться с увеличением MPC.
________________________________________

  Re-Usability
  
может уменьшаться с увеличением MPC.

-Learnability for Reuse:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, которые также необходимо понимать.
Обучаемость может снижаться с увеличением MPC.
________________________________________

-Operability for Reuse - Programmability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, представляющие зависимости.
Программируемость может уменьшиться с увеличением MPC.
________________________________________

  Efficiency
  
может уменьшаться с увеличением MPC.

-Time Behavior:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны поведению во времени, поскольку они используют другие части системы, поэтому выполнение во время теста или операции не остается локальным, а может включать в себя огромные части системы.
Поведение во времени может ухудшиться с увеличением MPC.
________________________________________

-Resource Utilization:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны использованию ресурсов, поскольку они используют другие части системы, таким образом, выполнение во время тестирования или работы не остается локальным, а может включать в себя огромные части системы.
Использование ресурсов может ухудшиться с увеличением MPC.
________________________________________
________________________________________________________________________________________________________________________________________________________________

    Non-Commenting Source Statements (NCSS)
    
Определяет сложность классов путем подсчета исходных утверждений без комментариев. NCSS рассчитывается путем подсчета исходных строк, не являющихся комментариями, что почти эквивалентно подсчету точек с запятой и открывающих фигурных скобок. Комментарии и пустые операторы игнорируются. Слишком большие классы трудно читать и дорого поддерживать. Большой номер NCSS часто означает, что класс имеет слишком много обязанностей и/или функций, которые следует разбить на более мелкие единицы.

Описано и реализовано Chr. Clemens Lee в JavaNCSS-Tool.

Обычное значение метрики NCSS по умолчанию меньше 1000.
________________________________________________________________________________________________________________________________________________________________

    Number Of Added Methods (NOAM)
    
Эта метрика подсчитывает количество методов, добавленных данным классом. Унаследованные и переопределенные методы не учитываются.

Входит в набор показателей, предложенный M. Lorenz and J. Kidd, см.

M. Lorenz, J. Kidd, вЂњObject Oriented Software MetricsвЂќ, Prentice Hall, NJ, 1994.
________________________________________________________________________________________________________________________________________________________________

    Number Of Attributes (NOA)
    
Эта метрика подсчитывает количество атрибутов данного класса.

Входит в набор показателей, предложенный M. Lorenz and J. Kidd, см.

M. Lorenz, J. Kidd, вЂњObject Oriented Software MetricsвЂќ, Prentice Hall, NJ, 1994.

Согласно с

FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.

обычное значение этой метрики меньше 4, случайное — от 4 до 8, редкое — больше 8.
________________________________________________________________________________________________________________________________________________________________

    Number Of Attributes And Methods (SIZE2)
    
    
Количество атрибутов и методов просто подсчитывает количество атрибутов и методов класса. Это объектно-ориентированная метрика, которую можно применять к модульным языкам, учитывая количество переменных (глобально видимых в модуле) и количество функций и процедур.

Входит в набор показателей, предложенный Li and Henry, см.

W. Li and S. Henry. Object-oriented metrics that predict maintainability. Journal of Systems and Software, Volume 23, Issue 2, pages 111-122, November 1993.
________________________________________

  Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
SIZE2 оказывает как отрицательное, так и положительное влияние.

-Understandability for Reuse:

Понимание того, подходит ли класс для повторного использования, зависит от его размера.
Понятность снижается с увеличением SIZE2.
________________________________________

-Learnability for Reuse:

Изучение того, подходит ли класс для повторного использования, зависит от размера и сложности его интерфейса. SIZE2 измеряет размер интерфейса.
Обучаемость может снижаться с увеличением SIZE2.
________________________________________

-Operability for Reuse - Programmability:

Насколько хорошо класс может быть интегрирован, зависит от сложности его интерфейса. SIZE2 измеряет размер интерфейса.
Программируемость может снизиться с увеличением SIZE2.
________________________________________

-Attractiveness:

Привлекательность класса зависит от размера потенциально повторно используемого кода.
Привлекательность увеличивается с увеличением SIZE2.
________________________________________

  Maintainability

уменьшается с увеличением SIZE2.

-Analyzability:

Затрачиваемые усилия и время на диагностику недостатков или причин сбоев в программном объекте или на идентификацию частей, подлежащих модификации, напрямую связаны с его размером.
Анализируемость снижается с увеличением SIZE2.
________________________________________

-Changeability:

Изменение класса требует предварительного понимания, что, в свою очередь, более сложно для больших систем.
Изменчивость снижается с увеличением SIZE2.
________________________________________

-Testability:

Полное тестирование требует охвата всех путей выполнения. Количество возможных путей выполнения системы увеличивается с ее размером.
Тестируемость снижается с увеличением SIZE2.
________________________________________

  Portability

уменьшается с увеличением SIZE2.

-Adaptability:

Что касается изменчивости, размер программного обеспечения имеет прямое влияние. Каждая модификация требует понимания, что сложнее для больших систем.
Адаптивность снижается с увеличением SIZE2.
________________________________________

-Replaceablity:

Заменитель компонента должен имитировать его интерфейс. Большие интерфейсы трудно проверить на взаимозаменяемость и реально заменить. Размер интерфейса специально оценивается SIZE2.
Заменяемость снижается с увеличением SIZE2.
________________________________________

  Связанные качественные свойства
________________________________________

  Functionality

может увеличиться с увеличением SIZE2.

-Interoperability:

Совместимость требует возможности локализовать части системы, отвечающие за совместимость. Размер в этих частях может указывать на лучшую способность к взаимодействию.
Совместимость может увеличиться с увеличением размера SIZE2.
________________________________________

-Security:

Чтобы связать SIZE2 с безопасностью, необходимо иметь возможность найти части системы, отвечающие за безопасность. Размер этих частей может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением размера SIZE2.
________________________________________

  Reliability

может увеличиться с увеличением SIZE2.

-Maturity:

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут оставаться ошибки. Таким образом, на зрелость также может негативно повлиять размер интерфейса.
Зрелость может снижаться с увеличением размера SIZE2.
________________________________________

-Fault-tolerance:

Чтобы связать SIZE2 с отказоустойчивостью, необходимо иметь возможность локализовать части системы, отвечающие за отказоустойчивость. Размер этих частей может указывать на лучшую способность к взаимодействию.
Отказоустойчивость может увеличиться с увеличением SIZE2.
________________________________________

-Recoverability:

Чтобы связать SIZE2 с восстанавливаемостью, необходимо иметь возможность найти части системы, ответственные за восстанавливаемость. Размер этих частей может указывать на более высокую степень восстановления.
Возможность восстановления может увеличиться с увеличением размера SIZE2.
________________________________________

  Efficiency

может уменьшаться с увеличением размера SIZE2.

-Time Behavior:

Статический размер может указывать на более высокое время выполнения из-за увеличения количества промахов кэша инструкций, длинных переходов и т. д.
Поведение времени может ухудшиться с увеличением SIZE2.
________________________________________

-Resource Utilization:

Статический размер может указывать на более высокое использование памяти.
Использование ресурсов может ухудшиться с увеличением размера SIZE2.
________________________________________

  Maintainability

уменьшается с увеличением SIZE2.

-Stability:

Из-за ограниченной анализируемости и тестируемости размер также может отрицательно влиять на стабильность.
Стабильность может снижаться с увеличением SIZE2.
________________________________________
________________________________________________________________________________________________________________________________________________________________

    Number of Children (NOC)
    
    
Вычисляет общее количество прямых подклассов данного класса. Эта метрика измеряет, сколько подклассов унаследуют методы родительского класса. Размер NOC приблизительно указывает уровень повторного использования в приложении. Если NOC растет, это означает увеличение повторного использования. С другой стороны, по мере увеличения NOC будет увеличиваться и объем тестирования, поскольку большее количество наследников в классе указывает на большую ответственность. Таким образом, NOC представляет усилия, необходимые для тестирования класса и повторного использования.

Входит в набор показателей, предложенный Chidamber and Kemerer, см.

S. R. Chidamber and C. F. Kemerer. A Metrics Suite for Object Oriented Design. In IEEE Transactions on Software Engineering, volume 20 (6), pages 476-493, June 1994.

Согласно с

FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.

обычное значение этой метрики меньше 2, случайное — между 2 и 3, редкое — больше 3.
________________________________________

  Сильно связанные качественные свойства
________________________________________

  Re-Usability

положительно влияют атрибуты, оцениваемые с помощью NOC.

-Understandability for Reuse:

Понимание класса поддерживается, если у него большое количество дочерних элементов. Первые многочисленные дети прямо показывают высокое повторное использование (reusability) рассматриваемого класса. Кроме того, с многочисленными детьми существует множество примеров повторного использования класса, которые помогают понять, подходит ли класс и как его можно повторно использовать для конкретных задач.
Понятность увеличивается с увеличением NOC.
________________________________________

-Learnability for Reuse:

Обучение (приобретение и запоминание знаний) тому, как (повторно) использовать класс путем его расширения, зависит от количества детей в рассматриваемом классе. Большое количество дочерних элементов, то есть много повторно используемых дочерних классов, позволяет получить разносторонние знания о том, как повторно использовать конкретный класс в различных ситуациях. Благодаря избыточности это поддерживает запоминание знаний о том, как повторно использовать конкретный класс.
Обучаемость увеличивается с увеличением NOC.
________________________________________

-Operability for Reuse:

Понимание того, может ли класс быть интегрированным и контролироваться инженерами/разработчиками программного обеспечения, зависит от количества дочерних элементов в классе. Большое количество детей указывает на то, что конкретный класс хорошо интегрирован в существующую программную систему. Это означает, что он подходит для нескольких разных задач, самоописателен, поскольку существует множество примеров его использования, имеет более высокую устойчивость к ошибкам, поскольку он задействуется каждый раз, когда тестируется один из его дочерних элементов.
Работоспособность увеличивается с увеличением NOC.
________________________________________

-Attractiveness for Reuse:

Класс с большим количеством детей кажется более привлекательным для инженера-программиста/разработчика. Это привлекает внимание на диаграмме классов или других представлениях, поскольку выделяется множеством дочерних элементов. Связанные предположения могут заключаться в том, что класс стабилен, поскольку он проверяется каждый раз, когда тестируется дочерний элемент, что хорошо задокументировано и понятно, поскольку есть много примеров использования, это помогает понять дочерние элементы, если родительский класс был понят, то есть играет центральную роль в дизайне, поскольку многие классы расширяют его функциональность.
Привлекательность увеличивается с увеличением NOC.
________________________________________

  Maintainability

отрицательно и положительно влияют атрибуты, оцениваемые с помощью NOC.

-Changeability:

Класс с большим количеством детей имеет меньшую изменчивость. Усилия, затрачиваемые на модификацию, устранение ошибок или изменение среды, увеличиваются, поскольку многие дочерние классы расширяют свои функциональные возможности в зависимости от родительского класса. Побочные эффекты модификаций предсказать труднее. Удаление ошибок влияет на дочерние классы. Необходимость изменения среды приходится учитывать дочерним классам.
Изменчивость уменьшается с увеличением NOC.
________________________________________

  Portability

на него отрицательно влияют атрибуты, оцениваемые с помощью NOC.

-Replaceability:

Класс с большим количеством детей трудно заменить. Дети зависят от него, расширяя определенные функции, и могут зависеть от определенных функций, предоставляемых родительским классом. Трудно найти другой класс, удовлетворяющий этим специфическим потребностям, позволяющий заменить родительский класс.
Заменяемость уменьшается с увеличением NOC.
________________________________________

  Связанные качественные свойства
________________________________________

  Reliability

Положительно влияют атрибуты, оцениваемые с помощью

-Maturity:

Класс с большим количеством детей имеет высокую зрелость. Частота отказов из-за ошибок невелика, поскольку многие ошибки были выявлены в различных способах взаимодействия дочерних классов с родителями. Родительский класс интенсивно используется, поскольку он используется каждый раз, когда используется дочерний класс.
Зрелость увеличивается с увеличением NOC.
________________________________________

  Maintainability

положительно и отрицательно влияют атрибуты, оцениваемые с помощью NOC.

-Analysability:

Анализ класса с большим количеством детей требует больших усилий. В диагностике недостатков или причин сбоев участвуют дети родительского класса. У них есть доступ к функциям и данным, предоставляемым классом, и они должны участвовать в анализе. Идентификация частей в родительском классе, которые необходимо изменить, требует анализа всех дочерних классов, на которые влияет модификация. Чтобы полностью проанализировать класс, также необходимо посмотреть на его потомков, чтобы получить полную картину.
Анализируемость снижается с увеличением NOC.
________________________________________

-Stability:

Класс с большим количеством детей несет более высокий риск неожиданного эффекта модификации. Дочерние классы повторно используют родительские классы различными способами. На них непосредственно влияют модификации, что затрудняет прогнозирование того, насколько стабильным будет класс или программный продукт после модификации.
Стабильность снижается с увеличением NOC.
________________________________________

-Testability:

Класс с большим количеством детей требует больших усилий для проверки модифицированного программного обеспечения. Все зависимые дочерние классы также должны быть включены в тесты, поскольку изменения в родительском классе напрямую влияют на расширяющиеся дочерние классы. Увеличено количество разработанных и реализованных функций автономного тестирования и сложность тестирования.
Тестируемость снижается с увеличением NOC.
________________________________________

  Portability

на него отрицательно влияют атрибуты, оцениваемые с помощью NOC.

-Adaptability:

Классу с большим количеством детей трудно адаптироваться к различным заданным условиям.Дети зависят от него, расширяя определенные функции, и могут зависеть от определенных функций, предоставляемых родительским классом. Адаптация родительского класса к новой среде может сделать его непригодным для дочерних классов, потребовав адаптации и в них.
Адаптивность снижается с увеличением NOC.
________________________________________
________________________________________________________________________________________________________________________________________________________________

    Number Of Methods (NOM)
    
    
Number Of Methods NOM(C)
is defined as the number of local methods in a class C. NOM measures the number of methods locally declared in a class. Inherited methods are not considered. It is the size of the interface of a class and allows conclusions on its complexity.

Included in the set of metrics proposed by Li and Henry, see

W. Li and S. Henry. Object-oriented metrics that predict maintainability. Journal of Systems and Software, Volume 23, Issue 2, pages 111-122, November 1993.

According to

FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.

common value for this metric is less than 7, casual - between 7 and 14, uncommon is greater than 14.
________________________________________

  Highly Related Software Quality Properties

  Re-Usability

is both negatively and positively influenced by NOM.

-Understandability for Reuse:

Understanding if a class is suitable for reuse depends on its size.
Understandability declines with increasing NOM.
________________________________________

-Learnability for Reuse:

Learning if a class is suitable for reuse depends on the size and complexity of its interface. NOM measures interface size.
Learnability might decline with increasing NOM.
________________________________________

-Operability for Reuse - Programmability:

How well a class can be integrated depends the complexity of its interface. NOM measures interface size.
Programmability might decline with increasing NOM.
________________________________________

-Attractiveness:

Attractiveness of a class depends on the size of the potentially reused code.
Attractiveness increases with increasing NOM.
________________________________________

  Maintainability

declines with increasing NOM.

-Analyzability:

The effort and time for diagnosis of deficiencies or causes of failures in software entity, or for identification of parts to be modified is directly related to its size.
Analyzability declines with increasing NOM.
________________________________________

-Changeability:

Changing a class requires prior understanding, which, in turn, is more complicated for large systems.
Changeability declines with increasing NOM.
________________________________________

-Testability:

Complete testing requires coverage of all execution paths. The number of possible execution paths of a system increases with its size.
Testability declines with increasing NOM.
________________________________________

  Portability

declines with increasing NOM.

-Adaptability:

As for changeability, the size of software has a direct impact. Each modification requires understanding which is more complicated for large systems.
Adaptability declines with increasing NOM.
________________________________________

-Replaceablity:

The substitute of a component must imitate its interface. Large interfaces are difficult to check for substitutability and to actually substitute. Interface size is specifically assessed by NOM.
Replaceablity decline with increasing NOM.
________________________________________

  Related Software Quality Properties
________________________________________

  Functionality

might increase with increasing NOM.

-Interoperability:

Interoperability requires to be able to locate the parts of a system responsible for interoperability. The size of in these parts might indicate a better ability to interact.
Interoperability might increase with increasing NOM.
________________________________________

-Security:

Relating NOM to security requires to be able to locate the parts of a system responsible for security. The size of these parts might indicate a higher security.
Security might increase with increasing NOM.
________________________________________

  Reliability

might increase with increasing NOM.

-Maturity:

Due to reduced analyzability and testability, bugs mights be left in the software. Therefore, also maturity may be influenced negatively by interface size.
Maturity might decline with increasing NOM.
________________________________________

-Fault-tolerance:

Relating NOM to fault-tolerance requires to be able to locate the parts of a system responsible for fault-tolerance. The size of these parts might indicate a better ability to interact.
Fault-Tolerance might increase with increasing NOM.
________________________________________

-Recoverability:

Relating NOM to recoverability requires to be able to locate the parts of a system responsible for recoverability. The size of these parts might indicate a higher recoverability.
Recoverability might increase with increasing NOM.
________________________________________

  Efficiency

might decline with increasing NOM.

-Time Behavior:

Static size might indicate a higher execution time due to increased number of instruction cache misses, long jumps, etc.
Time behavior might get worse with increasing NOM.
________________________________________

-Resource Utilization:

Static size might indicate a higher memory utilization.
Resource utilization might get worse with increasing NOM.
________________________________________

  Maintainability

declines with increasing NOM.

-Stability:
Due to reduced analyzability and testability, also stability may be influenced negatively by size.
Stability might decline with increasing NOM.
________________________________________
________________________________________________________________________________________________________________________________________________________________
