#Метрики класса:

  -Condition Nesting Depth(Глубина вложенности условия) - Эта метрика измеряет максимальную глубину вложенности операторов условий. Когда операторы слишком глубоко вложены в код, их становится трудно понять. Это связано с тем, что для понимания глубоко вложенной строки требуется понимание контекста этой строки. Метод с высоким уровнем вложенности может быть очень сложным для понимания. Как подмечено в S. McConnell, Code Complete, 2nd Edition, В§19.4. Microsoft Press, 2004.
  человеческий мозг не может легко обрабатывать более трех уровней вложенных операторов if.
  __________________________________________________________________________________________________________________________________________________________________
  
  -Lines Of Code - Строки кода просто подсчитывают строки исходного кода (символы разрыва строк) определенного метода. Это простая, но мощная метрика для оценки сложности методов. Поскольку метрика зависит от соглашений и формата кода, очень важно использовать ее в сгенерированном коде, поскольку в нем могут отсутствовать разрывы строк. Кроме того, ее можно измерить только в самом исходном коде с front-end, и поэтому она является метрикой front-end.
  
  Согласно FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55. Обычное значение метрики меньше 11, случайное между 11 и 30, редкое свыше 30
  
  Сильно связанные качественные свойства
  ________________________________________

    Re-Usability

как отрицательно, так и положительно зависит от размера.

-Understandability for Reuse

Понимание того, подходит ли класс для повторного использования, зависит от его размера. Понятность снижается с увеличением LOC
Понятность снижается с увеличением LOC.
________________________________________

-Attractiveness

Привлекательность метода зависит от размера потенциально повторно используемого кода.
Привлекательность увеличивается с увеличением LOC.
________________________________________

    Maintainability

уменьшается с увеличением LOC.

-Analyzability

Затрачиваемые усилия и время на диагностику недостатков или причин сбоев в методе или на идентификацию частей, подлежащих модификации, напрямую связаны с его размером.

Анализируемость снижается с увеличением LOC.
________________________________________

-Changeability

Изменение метода требует предварительного понимания, что, в свою очередь, более сложно для больших систем.
Изменчивость снижается с увеличением LOC.
________________________________________

-Testability

Полное тестирование требует охвата всех путей выполнения. Количество возможных путей выполнения метода увеличивается с его размером.
Тестируемость снижается с увеличением LOC.
________________________________________

    Portability

declines with increasing LOC.

-Adaptability

Что касается изменчивости, размер метода имеет прямое влияние. Каждая модификация требует понимания, что сложнее для больших систем.
Адаптивность снижается с увеличением LOC.
________________________________________


    Связанные качественные свойства

    Functionality
может увеличиться с увеличением LOC.

-Interoperability

Совместимость требует возможности локализовать части системы, отвечающие за совместимость. Размер этих частей может указывать на лучшую способность к взаимодействию.
Совместимость может увеличиться с увеличением LOC.
________________________________________

-Security

Чтобы связать LOC с безопасностью, необходимо иметь возможность определить местонахождение частей системы, отвечающих за безопасность. Размер этих частей может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением LOC.
________________________________________

    Reliability
    
может увеличиться с увеличением LOC

-Maturity

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут остаться ошибки. Следовательно, на зрелость также может отрицательно влиять размер кода.
Зрелость может снизиться с увеличением LOC.
________________________________________

-Fault-tolerance

Чтобы связать LOC с отказоустойчивостью, необходимо иметь возможность локализовать части системы, отвечающие за отказоустойчивость. Размер этих частей может указывать на лучшую способность к взаимодействию.
Отказоустойчивость может увеличиваться с увеличением LOC.
________________________________________

-Recoverability

Чтобы связать LOC с восстанавливаемостью, необходимо иметь возможность найти части системы, ответственные за восстанавливаемость. Размер этих частей может указывать на более высокую степень восстановления.
Восстанавливаемость может увеличиться с увеличением LOC.
________________________________________

    Re-Usability
    
может уменьшаться с увеличением LOC.

-Learnability for Reuse

Изучение того, подходит ли метод для повторного использования, зависит от размера и сложности его интерфейса. LOC — это общая метрика размера, но не конкретная оценка размера и сложности интерфейса.
Обучаемость может снижаться с увеличением LOC.
________________________________________

-Operability for Reuse - Programmability

Насколько хорошо класс может быть интегрирован, зависит от сложности его интерфейса. LOC — это общая метрика размера, но не конкретная оценка размера и сложности интерфейса.
Программируемость может снижаться с увеличением LOC.
________________________________________

    Efficiency
может снижаться с увеличением LOC.

-Time Behavior

Статический размер может указывать на более высокое время выполнения из-за увеличения количества промахов кэша инструкций, длинных переходов и т. д.
Поведение во времени может ухудшиться с увеличением LOC.
________________________________________

-Resource Utilization

Статический размер может указывать на более высокое использование памяти.
Использование ресурсов может ухудшиться с увеличением LOC.
________________________________________

    Maintainability
    
уменьшается с увеличением LOC.

-Stability

Из-за ограниченной анализируемости и тестируемости размер также может отрицательно влиять на стабильность.
Стабильность может снижаться с увеличением LOC.
________________________________________

    Portability
уменьшается с увеличением LOC.

-Replaceablity

Заменитель компонента должен имитировать его наблюдаемое поведение. Большие компоненты могут иметь более сложное наблюдаемое поведение, что затрудняет проверку взаимозаменяемости и фактическую замену компонента. Размер и сложность интерфейса, атрибут, напрямую связанный с заменяемостью, специально не оцениваются LOC.
Заменяемость может снижаться с увеличением LOC.
________________________________________
  
  __________________________________________________________________________________________________________________________________________________________________
  -Loop Nesting Depth(Глубина вложенности циклов) - Эта метрика измеряет максимальную глубину вложенности операторов цикла. Когда операторы слишком глубоко вложены в код, их становится трудно понять. Это связано с тем, что для понимания глубоко вложенной строки требуется понимание контекста этой строки. Метод с высоким уровнем вложенности может быть очень сложным для понимания. Кроме того, значение этой метрики может быть полезно для оценки временной сложности данного метода.
  
   __________________________________________________________________________________________________________________________________________________________________
    McCabe Cyclomatic Complexity (CC)
McCabe Cyclomatic Complexity (CC) это мера управления структурой сложности программного обеспечения. это количество линейно независимых путей и, следовательно минимальное количество путей выполнения ПО. 

Согласно с

FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.
обычное значение этой метрики меньше 3, случайное — между 3 и 4, редкое — больше 4.

________________________________________
    Сильно связанные качественные свойства
    
    Re-Usability
как отрицательно, так и положительно влияет атрибутивная оценка с цикломатической сложностью.

-Understandability for Reuse

Понимание того, подходит ли класс для повторного использования, зависит от его сложности.
Понятность снижается с увеличением цикломатической сложности.
________________________________________

-Learnability for Reuse

Изучение того, подходит ли класс для повторного использования, зависит от сложности его интерфейса. Системы с высокой сложностью управления также могут иметь сложный (поведенческий) интерфейс.
Обучаемость снижается с увеличением цикломатической сложности.
________________________________________

-Operability for Reuse - Programmability

Насколько хорошо класс может быть интегрирован, зависит от сложности его интерфейса. Системы с высокой сложностью управления также могут иметь сложный (поведенческий) интерфейс.
Программируемость снижается с увеличением цикломатической сложности.
________________________________________

-Attractiveness

Привлекательность класса зависит от сложности потенциально повторно используемого кода. Цикломатическая сложность позволяет оценить сложность.
Привлекательность увеличивается с увеличением цикломатической сложности.
________________________________________

    Maintainability
снижается с увеличением цикломатической сложности.

-Analyzability

Затрачиваемые усилия и время на диагностику недостатков или причин отказов или на идентификацию частей, подлежащих модификации, напрямую связаны с количеством путей выполнения, т. е. сложностью потока управления.
Анализируемость снижается с увеличением цикломатической сложности.
________________________________________

-Changeability

Каждая модификация должна быть правильной для всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Изменчивость снижается с увеличением цикломатической сложности.
________________________________________

-Testability

Полное тестирование требует охвата всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Тестируемость снижается с увеличением цикломатической сложности.
________________________________________

    Portability
снижается с увеличением цикломатической сложности.

-Adaptability

Что касается изменчивости, то непосредственное влияние оказывает сложность управляющей структуры программного обеспечения. Каждая модификация должна быть правильной для всех путей выполнения. Цикломатическая сложность вычисляет количество линейно независимых путей, нижнюю границу всех путей выполнения, игнорируя множественные итерации.
Адаптивность снижается с увеличением цикломатической сложности.
________________________________________

-Replaceablity

Заменитель компонента должен имитировать его наблюдаемое поведение. Компоненты со сложными управляющими структурами могут иметь более сложное наблюдаемое поведение, что затрудняет проверку взаимозаменяемости и фактическую замену компонента.
Заменяемость снижается с увеличением цикломатической сложности.
________________________________________

    Связанные качественные свойства
________________________________________    
    
    Functionality
    
может увеличиваться с увеличением цикломатической сложности.

-Interoperability

Связь цикломатической сложности с совместимостью требует наличия частей системы, ответственных за совместимость. Сложность в этих частях может указывать на лучшую способность к взаимодействию.
________________________________________

-Security

Чтобы связать цикломатическую сложность с безопасностью, необходимо уметь находить части системы, отвечающие за безопасность. Сложность в этих частях может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением цикломатической сложности.
________________________________________

    Reliability
    
может увеличиваться с увеличением цикломатической сложности.


-Maturity

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут оставаться ошибки. Следовательно, на зрелость также может негативно повлиять сложность потока управления.
Зрелость может снижаться с увеличением цикломатической сложности.
________________________________________

-Fault-tolerance

Для связи цикломатической сложности с отказоустойчивостью необходимо иметь возможность локализовать части системы, отвечающие за отказоустойчивость. Сложность в этих частях может указывать на лучшую способность к взаимодействию.
________________________________________

-Recoverability

Связь цикломатической сложности с восстанавливаемостью требует возможности локализовать части системы, ответственные за восстанавливаемость. Сложность в этих частях может указывать на более высокую возможность восстановления. Возможность восстановления может увеличиться с увеличением CC
________________________________________

    Efficiency
    
может снижаться с увеличением цикломатической сложности.

-Time Behavior

Статическая сложность может указывать на более высокую сложность выполнения.
Поведение времени может ухудшиться с увеличением цикломатической сложности.
________________________________________

    Maintainability
снижается с увеличением цикломатической сложности.
________________________________________

-Stability

Из-за ограниченной анализируемости и тестируемости на стабильность также может отрицательно повлиять сложность потока управления.
Стабильность может снижаться с увеличением цикломатической сложности.
________________________________________
________________________________________________________________________________________________________________________________________________________________
Number Of Loops

Этот показатель измеряет количество циклов в данном методе.
________________________________________________________________________________________________________________________________________________________________

Number Of Parameters To Method
Эта метрика измеряет количество параметров метода или конструктора. Метод (или конструктор), который использует большое количество формальных параметров, усложняет обслуживание:
Написать вызов метода сложно, потому что программист должен знать, как указать соответствующее значение для каждого параметра.
Внешне сложно понять, потому что вызовы метода длиннее одной строчки кода.
Внутренне сложно понять, потому что у него так много зависимостей.
Robert C. Martin, in [1], пишет (page 40):
Идеальное количество аргументов для функции равно нулю (ниладический). Далее идет один (монадический), за ним два (диадический). По возможности следует избегать трех аргументов (троичных). Более трех (полиадический) требует особого обоснования, и тогда его не следует использовать в любом случае.
Ограничьте количество формальных параметров для метода в зависимости от причины большого числа:
Некоторые параметры логически связаны, но передаются в метод по отдельности. Параметры, которые логически связаны, должны быть сгруппированы вместе (see the 'Introduce Parameter Object' refactoring on pp. 238-242 of [2]).
У метода слишком много обязанностей. Он должен быть разбит на несколько методов (see the 'Extract Method' refactoring on pp. 89-95 of [2]), и каждому новому методу должно быть передано подмножество исходных параметров.
Метод имеет избыточные параметры, которые не используются. Две основные причины этого: (1) параметры были добавлены для расширения в будущем, но никогда не используются;(2) тело метода было изменено таким образом, что он больше не использует определенные параметры, но сигнатура метода не была соответствующим образом обновлена. В обоих случаях теоретически правильным решением является удаление неиспользуемых параметров. (see the 'Remove Parameter' refactoring on pp. 223-225 of [2]), хотя вы должны делать это осторожно, если метод является частью опубликованного интерфейса.
Когда метод является частью опубликованного интерфейса, одним из возможных решений является добавление в интерфейс нового метода-оболочки с более аккуратной подписью. Кроме того, вы можете опубликовать новую версию интерфейса с улучшенным дизайном.Однако ясно, что ни одно из этих решений не является идеальным, поэтому вам следует с самого начала позаботиться о правильном проектировании интерфейсов. Особенно плоха практика добавления параметров для будущей расширяемости. Это сбивает с толку других программистов, которые не уверены, какие значения им следует передавать для этих ненужных параметров, и добавляет неиспользуемый код, который потенциально трудно удалить позже.
1. Robert C. Martin. Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall, 2008.
2. Martin Fowler. Refactoring. Addison-Wesley, 1999.
 ________________________________________________________________________________________________________________________________________________________________

    Data Abstraction Coupling (DAC)


Data Abstraction Coupling DAC(C) определяется как количество атрибутов в классе C, которые имеют другой класс в качестве своего типа. DAC измеряет сложность связи, вызванную абстрактными типами данных (ADT). Этот показатель связан со связью между классами, представляющими основной аспект ООП, поскольку степень повторного использования, усилия по обслуживанию и тестированию класса в решающей степени зависят от уровня связи между классами.
Входит в набор показателей, предложенный Ли и Генри, см.

W. Li and S. Henry. Object-oriented metrics that predict maintainability. Journal of Systems and Software, Volume 23, Issue 2, pages 111-122, November 1993.

  Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
отрицательно влияет сцепление.

-Understandability for Reuse:

Часть системы, имеющая высокую (исходящую) эфферентную связь, может быть в значительной степени обратно связана с понятностью, поскольку она использует другие части системы, которые также необходимо понять.
Понятность снижается с увеличением DAC.
________________________________________

-Attractiveness:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с привлекательностью, поскольку они используют другие части системы, которые также необходимо понимать, и представляют собой зависимости.
Привлекательность снижается с увеличением DAC.
________________________________________

  Maintainability

уменьшается с увеличением DAC.


-Analyzability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно пропорциональны анализируемости, поскольку они используют другие части системы, которые также необходимо анализировать.
Анализируемость снижается с увеличением DAC.
________________________________________

-Changeability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны изменчивости, поскольку они используют другие части системы, которые также могут нуждаться в изменении.
Изменчивость уменьшается с увеличением DAC.
________________________________________

-Stability:

Части, демонстрирующие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны стабильности, поскольку они используют другие части системы, которые могут влиять на них.
Стабильность снижается с увеличением DAC.
________________________________________

-Testability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть сильно обратно связаны с тестируемостью, поскольку они используют другие части системы, которые увеличивают количество возможных путей тестирования.
Тестируемость снижается с увеличением DAC.
________________________________________

  Portability
  
уменьшается с увеличением DAC.


-Adaptability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны адаптивности, поскольку они используют другие части системы, которые также могут нуждаться в адаптации.
Адаптивность снижается с увеличением DAC.
________________________________________

  Связанные качественные свойства
  ________________________________________
  
  Functionality
  
взаимосвязь оказывает как отрицательное, так и положительное влияние.


-Interoperability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть непосредственно связаны с интероперабельностью, поскольку они используют/взаимодействуют с другими частями системы.
Совместимость может увеличиться с увеличением DAC.
________________________________________

-Security:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны безопасности, поскольку на них могут влиять проблемы безопасности в других частях системы.
Безопасность может снизиться с увеличением DAC.
________________________________________

  Reliability
может уменьшаться с увеличением DAC.

-Fault-tolerance:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны отказоустойчивости, поскольку на них могут влиять сбои в других частях системы.
Отказоустойчивость может снизиться с увеличением DAC.
________________________________________

-Recoverability:

Части, имеющие высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны восстанавливаемости, поскольку их данные распределяются по другим частям системы, что затрудняет их восстановление.
Восстанавливаемость может уменьшиться с увеличением DAC.
________________________________________

  Re-Usability
  
может уменьшаться с увеличением DAC.

-Learnability for Reuse:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, которые также необходимо понимать.
Обучаемость может снизиться с увеличением DAC.
________________________________________

-Operability for Reuse - Programmability:

Части, которые имеют высокую (исходящую) эфферентную связь, могут быть обратно пропорциональны обучаемости, поскольку они используют другие части системы, представляющие зависимости.
Программируемость может уменьшиться с увеличением DAC.
________________________________________

  Efficiency
  
может уменьшаться с увеличением DAC.

-Time Behavior:

Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны поведению во времени, поскольку они используют другие части системы, поэтому выполнение во время теста или операции не остается локальным, а может включать в себя огромные части системы.
Поведение во времени может ухудшиться с увеличением DAC.
________________________________________

Resource Utilization:
Части с высокой (исходящей) эфферентной связью могут быть обратно пропорциональны утилизации ресурсов, поскольку они используют другие части системы, поэтому выполнение во время тестирования или работы не остается локальным, а может включать в себя огромные части системы.
Использование ресурсов может ухудшиться с увеличением DAC.
________________________________________
________________________________________________________________________________________________________________________________________________________________


    Depth of Inheritance Tree (DIT)
    
Глубина дерева наследования (DIT) — это максимальная длина пути от класса к корневому классу в структуре наследования системы. DIT измеряет, сколько суперклассов может повлиять на класс.
Входит в набор показателей, предложенный Чидамбером и Кемерером, см.

S. R. Chidamber and C. F. Kemerer. A Metrics Suite for Object Oriented Design. In IEEE Transactions on Software Engineering, volume 20 (6), pages 476-493, June 1994.
According to
FiloМЃ, T. G., Bigonha, M., & Ferreira, K. 2015. A catalogue of thresholds for object-oriented software metrics. Proc. of the 1st SOFTENG, 48вЂ“55.

обычное значение этой метрики меньше 3, случайное — между 3 и 4, редкое — больше 4


   Сильно связанные качественные свойства
  ________________________________________
  
  Re-Usability
  
как отрицательно, так и положительно влияет атрибутивная оценка с помощью DIT.

-Understandability for Reuse:

Понимание того, подходит ли класс для повторного использования, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Понятность снижается с увеличением DIT.
________________________________________

-Learnability for Reuse:

Изучение того, как использовать класс, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Обучаемость снижается с увеличением DIT.
________________________________________

-Operability for Reuse - Programmability:

Насколько хорошо класс может быть интегрирован, зависит от размера его интерфейса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Программируемость снижается с увеличением DIT.
________________________________________

-Attractiveness:

Привлекательность класса зависит от размера потенциально повторно используемого javaCode. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов.
Привлекательность увеличивается с увеличением DIT.
________________________________________

  Maintainability
  
уменьшается с увеличением ДИТ.

-Analyzability:

Затрачиваемые усилия и время на диагностику недостатков или причин отказов в классе или на идентификацию частей, подлежащих модификации, связаны с количеством методов класса. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Анализируемость снижается с увеличением DIT.
________________________________________

-Changeability:

Изменение класса требует предварительного понимания, что, в свою очередь, более сложно для классов со многими методами. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Более того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его понимание.
Изменчивость снижается с увеличением DIT.
________________________________________

-Testability:

Полное тестирование требует охвата всех путей выполнения. Количество возможных путей выполнения класса увеличивается с количеством методов и сложностью их потока управления. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Из-за позднего связывания методы суперкласса необходимо снова тестировать в контексте подкласса. Это потенциально усложняет тестирование классов глубоко в иерархии классов.
Тестируемость снижается с увеличением DIT.
________________________________________

  Portability
  
уменьшается с увеличением ДИТ.

-Adaptability:

Что касается изменчивости, размер программного обеспечения имеет прямое влияние. Классы, расположенные глубоко в иерархии классов, потенциально могут наследовать многие методы от суперклассов. Кроме того, определения унаследованных методов не являются локальными для класса, что еще больше затрудняет его анализ.
Адаптивность снижается с увеличением DIT.
________________________________________

-Replaceablity:

Заменитель компонента должен имитировать его интерфейс. Большие интерфейсы трудно проверить на взаимозаменяемость и реально заменить. Размер интерфейса увеличивается для классов, которые находятся глубоко в иерархии классов.
Заменяемость снижается с увеличением DIT.
________________________________________

  Связанные качественные свойства
  ________________________________________
  Functionality
  
может увеличиться с увеличением DIT.

-Interoperability:

Чтобы связать DIT с совместимостью, необходимо иметь возможность локализовать иерархические (под)структуры системы, ответственные за совместимость. Высокий DIT в этих иерархических (под)структурах может указывать на лучшую способность к взаимодействию.
Совместимость может увеличиться с увеличением DIT.
________________________________________

-Security:

Связь DIT с безопасностью требует наличия иерархических (под)структур системы, ответственных за совместимость. Высокое значение DIT в этих иерархических (под)структурах может указывать на более высокий уровень безопасности.
Безопасность может повыситься с увеличением DIT.
________________________________________

  Reliability
  
как положительно, так и отрицательно влияют атрибуты, оцениваемые с помощью DIT.

-Maturity:

Из-за ограниченной возможности анализа и тестирования в программном обеспечении могут оставаться ошибки. Следовательно, DIT также может негативно повлиять на зрелость.
Зрелость может снизиться с увеличением DIT.
________________________________________

-Fault-tolerance

Связь DIT с отказоустойчивостью требует наличия возможности локализовать иерархические (под)структуры системы, отвечающие за взаимодействие. Высокий DIT в этих иерархических (под)структурах может указывать на лучшую способность к взаимодействию.
Отказоустойчивость может увеличиться с увеличением DIT.
________________________________________

-Recoverability

Чтобы связать DIT с возможностью восстановления, необходимо иметь возможность локализовать иерархические (под)структуры системы, отвечающие за совместимость. Высокое значение DIT в этих иерархических (под)структурах может указывать на более высокую восстанавливаемость.
Восстанавливаемость может увеличиться с увеличением DIT.
________________________________________

  Efficiency
  
может снижаться с увеличением DIT.

-Time Behavior:

Статический размер может указывать на более высокое время выполнения из-за увеличения числа промахов кэша инструкций, длинных переходов и т. д. Классы, наследующие множество атрибутов, потенциально велики. Кроме того, позднее связывание требует непрямых вызовов и предотвращает оптимизацию в контексте вызывающего объекта.
Поведение во времени может ухудшиться с увеличением DIT.
________________________________________

-Resource Utilization:

Статический размер может указывать на более высокое использование памяти.
Использование ресурсов может ухудшиться с увеличением DIT.
________________________________________

  Maintainability
  
уменьшается с увеличением ДИТ.

-Stability:

Из-за ограниченной анализируемости и тестируемости размер также может отрицательно влиять на стабильность.
Стабильность может снижаться с увеличением DIT.
________________________________________
________________________________________________________________________________________________________________________________________________________________

Lack of Cohesion of Methods (LCOM)
The Lack of Cohesion in Methods metric is a measure for the number of not connected method pairs in a class representing independent parts having no cohesion. It represents the difference between the number of method pairs not having instance variables in common, and the number of method pairs having common instance variables.
Included in the set of metrics proposed by Chidamber and Kemerer, see
S. R. Chidamber and C. F. Kemerer. A Metrics Suite for Object Oriented Design. In IEEE Transactions on Software Engineering, volume 20 (6), pages 476-493, June 1994.
Highly Related Software Quality Properties
Reliability
is positively influenced by cohesion.
Maturity
Parts of a system showing a high cohesion may be highly directly related to maturity, since a mature system ought to have high cohesion values.
Maturity decreases with increasing LCOM.
Re-Usability
is negatively influenced by coupling.
Understandability for Reuse
Parts of a system showing a high cohesion may be highly directly related to understandability for reuse, since they implement only one concept.
Understandability decreases with increasing LCOM.
Attractiveness
Parts of a system showing a high cohesion may be highly directly related to attractiveness for reuse, since they implement only one concept.
Attractiveness decreases with increasing LCOM.
Maintainability
decreases with increasing LCOM.
Analyzability
Parts of a system showing a high cohesion may be highly directly related to analyzability, since they implement only one concept.
Analyzability decreases with increasing LCOM.
Changeability
Parts of a system showing a high cohesion may be highly directly related to changeability, since they implement only one concept.
Changeability decreases with increasing LCOM.
Stability
Parts of a system showing a high cohesion may be highly directly related to stability, since they implement only one concept.
Stability decreases with increasing LCOM.
Testability
Parts of a system showing a high cohesion may be highly directly related to testability, since they implement only one concept.
Testability decreases with increasing LCOM.
Portability
decreases with increasing LCOM.
Adaptability
Parts of a system showing a high cohesion may be highly directly related to adaptability, since they implement only one concept.
Adaptability decreases with increasing LCOM.
Related Software Quality Properties
Re-Usability
might decrease with increasing LCOM.
Learnability for Reuse
Parts of a system showing a high cohesion may be highly directly related to learnability, since they implement only one concept.
Learnability might decrease with increasing LCOM.
Operability for Reuse - Programmability
Parts of a system showing a high cohesion may be highly directly related to programmability, since they implement only one concept.
Programmability might decrease with increasing LCOM.
Efficiency
might decrease with increasing LCOM.
Time Behavior
Parts of a system showing a high cohesion may be directly related to time behavior, since they implement only one concept, and do not do any unrelated time consuming tasks.
Time behavior might get worse with increasing LCOM.
Resource Utilization
Parts of a system showing a high cohesion may be directly related to resource utilization, since they implement only one concept, and do not do any unrelated resource utilization.
Resource utilization might get worse with increasing LCOM.
Portability
decreases with increasing LCOM.
Replaceablity
Parts of a system showing a high cohesion may be directly related to replaceability, since they implement only one concept.
Replaceablity might decreases with increasing LCOM.
